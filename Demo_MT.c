/*
 * Demo_MT.c
 */ 

//////////////////////////////////////////////////////////////////////////
// Проект для демонстрации библиотеки MT.
// Для работы необходимо подключить двухосевой джойстик KY-023 к 
// Arduino NANO в соответствии со следующей таблицей:
// 
// Arduino NANO		Джойстик KY-023
// ------------------------
// GND				GND
// 5V				+5V
// A7				VRx
// A6				VRy
// A5				SW
//////////////////////////////////////////////////////////////////////////


// Ресурсы платы Arduino NANO (ATmega328P)
/*
Порт	Контакт		Вывод	Комментарии
		платы		МК
---------------------------------------
PB0		D8			12		PCINT0/CLKO/ICP1
PB1		D9			13		PCINT1/OC1A
PB2		D10			14		PCINT2/SS/OC1B 
PB3		D11			15		PCINT3/OC2A/MOSI (Программатор/MOSI)
PB4		D12			16		PCINT4/MISO (Программатор/MISO)
PB5		D13			17		PCINT5/SCK (Программатор/SCK, Светодиод)

PC0		A0			23		PCINT8/ADC0
PC1		A1			24		PCINT9/ADC1
PC2		A2			25		PCINT10/ADC2
PC3		A3			26		PCINT11/ADC3
PC4		A4			27		PCINT12/SDA/ADC4
PC5		A5			28		PCINT13/SCL/ADC5 (Джойстик KY-023/контакт SW)

		A6			19		ADC6 (Джойстик KY-023/контакт VRy)
		A7			22		ADC7 (Джойстик KY-023/контакт VRx)

PD0		RxD			30		PCINT16/RXD (Мост USB-UART)
PD1		TxD			31		PCINT17/TXD (Мост USB-UART)
PD2		D2			32		PCINT18/INT0
PD3		D3			1		PCINT19/INT1/OC2B
PD4		D4			2		PCINT20/XCK/T0
PD5		D5			9		PCINT21/T1/OC0B
PD6		D6			10		PCINT22/OC0A/AIN0
PD7		D7			11		PCINT23/AIN1

		RST			29		PCINT14/RESET/PC6
		GND			3,5,21	Общий (Джойстк KY-023/GND)
		AREF		20		AREF
		3.3V				120mA
		5V					USB 500mA. (Джойстик KY-023/+5V)
							Через этот контакт можно запитать Arduino Uno (+5V)
		VIN					6.5V...15V (Рекомендуется 7V...12V), (если не
							запитан через USB, то питание через этот
							контакт или через контакт 5V)
*/



// Включаемые файлы
//========================================================================
#include "Config.h"
#include "Mt.h"
#include "ADC.h"
#include "UART.h"



#define TASK_ACTIVE		TRUE
#define TASK_PASSIVE	FALSE

// Время, в течение которого не реагируем на дребезг кнопки, мс
#define DEBOUNCE_MS		80	

// Время паузы между переключениями светодиода в режиме быстрого
// моргания, мс
const uint16_t	ShortPauseHL = 100;
	
// Время паузы между переключениями светодиода в режиме медленного
// моргания, мс
const uint16_t	LongPauseHL = 500;

// Время, через которое переключается режим моргания светодиода, мс
const uint16_t	TimeBetweenModeHL = 5000;

// Переменная для хранения ID задачи, которая выводит на UART состояние
// кнопки SW джойстика при ее нажатии/отпускании
uint8_t idTask_SW = ID_UNKNOWN;
							
// Переменная для хранения ID задачи, которая выводит счетчик секунд
// по UART
uint8_t idTask_SEC = ID_UNKNOWN;

// Счетчик секунд. Переполняется каждые 4.6 часа.
volatile uint16_t CountSec = 0;




//////////////////////////////////////////////////////////////////////////
// Функция обратного вызова, которая вызывается из обработчика прерывания
// системного таймера. Для этого в файле Mt_Cfg.h прописан
// вызов функции CalcSec в теле макроса MT_SYSTIMER_CALLBACK().
// Каждую секунду переводит задачу Task_SEC в активное состояние.
//////////////////////////////////////////////////////////////////////////
void CalcSec(void)
{
	static uint16_t CountMs = 0; // Счетчик миллисекунд

	// Наращиваем счетчик миллисекунд в каждом прерывании системного
	// таймера
	CountMs += SYSTICK_TO_MS(1); // Макрос SYSTICK_TO_MS(1) преобразует
								// один системный такт в миллисекунды
	
	if (CountMs >= 1000) // Если прошло 1000 мс
	{
		CountMs = 0; // Обнуление счетчика миллисекунд
		CountSec++; // Инкремент счетчика секунд
		
		// Перевод задачи вывода секунд в активное состояние
		if (idTask_SEC != ID_UNKNOWN)
		{
			MT_TaskSetActiveIrq(idTask_SEC);
		}
	}
}
//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////
// Обработчик прерывания по изменению уровня сигнала на входе PC5
// микроконтроллера, к которому подключен сигнал от кнопки SW джойстика.
// Переводит задачу Task_SW в активное состояние.
//////////////////////////////////////////////////////////////////////////
ISR(PCINT1_vect)
{
	// Запрет прерываний по нажатию/отпусканию кнопки SW джойстика
	PCMSK1 &= ~(1 << PCINT13);
								
	// Перевод задачи, которая обслуживает кнопку в активное состояние
	if (idTask_SW != ID_UNKNOWN)
	{
		MT_TaskSetActiveIrq(idTask_SW);
	}
}
//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////
// Функция-протопоток для измерений с помощью АЦП.
// Для синхронизации доступа к АЦП из разных задач использует мьютекс.
//
// Параметры:
// Context - Указатель на контекст протопотока,
// Chanel - Номер канала АЦП,
// Result - Указатель на результат измерения.
//////////////////////////////////////////////////////////////////////////
PT_THREAD(ReadADC(struct pt *Context, uint8_t Chanel, uint8_t *Result))
{
	PT_BEGIN(Context); // Начало протопотока

	// Захват мьютекса АЦП.
	// --------------------
	// Если мьютекс окажется занятым, то текущая задача, вызвавшая данный
	// протопоток будет переведена в ждущее состояние и управление перейдет
	// в планировщик. После освобождения мьютекса ждущая задача снова
	// станет активной и продолжит выполнение с этого же места.
	MT_MutexWait(Context, MUTEX_ADC);

	// Настройка АЦП.
	// --------------
	// ADMUX_REF_AVCC - Опорное напряжение = AVCC (Напряжение питания)
	// ADMUX_DATA_LEFT - Выравнивание результата влево
	//	                 (оптимально для получения 8-битного результата)
	// Chanel - Канал измерения АЦП	
	// ПРИМЕЧАНИЕ: Константы ADMUX_REF_AVCC, ADMUX_DATA_LEFT определены в
	// файле ADC.h
	ADMUX = ADMUX_REF_AVCC | ADMUX_DATA_LEFT | Chanel;
	
	// Старт преобразования АЦП.
	// -------------------------
	// ПРИМЕЧАНИЕ: Константа ADCSRA_ADSC определена в файле ADC.h
	ADCSRA |= ADCSRA_ADSC;
	
	// Ждем, пока АЦП не закончит преобразование.
	// Здесь, если преобразование еще не завершилось, то управление
	// перейдет в планировщик.
	// При следующем вызове протопоток продолжит свою работу с этого же
	// места.
	PT_WAIT_WHILE(Context, ADCSRA & ADCSRA_ADSC);
	
	// Сохраняем результат преобразования
	*Result = ADCH;
	
	// Освобождение мьютекса АЦП.
	// --------------------------
	// С помощью этой функции все задачи, которые находятся в состоянии
	// ожидания освобождения этого мьютекса перейдут в активное состояние
	// и планировщик сможет их запустить на выполнение.
	MT_MutexFree(MUTEX_ADC);
	
	PT_END(Context); // Завершение протопотока
}
//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////
// Задача Task_X.
// Измеряет положения джойстика по оси X с помощью АЦП. В случае изменения
// положения выводит результат в UART.
//////////////////////////////////////////////////////////////////////////
PT_THREAD(Task_X(struct pt *Context))
{
	static struct pt ContextChild; // Контекст для дочернего протопотока
	static uint8_t adc;
	static uint8_t adc_old = 0;
	static char str[30];

	PT_BEGIN(Context); // Начало протопотока

	// Измерение положения джойстика по оси X с помощью АЦП.
	// (Вызов дочернего протопотока)
	PT_SPAWN(Context, &ContextChild,
		ReadADC(&ContextChild, ADMUX_MUX_7, &adc));

	// Если результат измерения отличается от предыдущего более чем на
	// одну дискрету, то вывод результата в UART
	if (abs(adc_old - adc) > 1)
	{
		adc_old = adc; // Сохраняем результат измерения
		
		// Формирование текстовой строки для вывода в UART
		sprintf(str, "Task_X: VRx = %d", adc);
		if (adc < 128) strcat (str, " (LEFT)\r\n");
		else strcat (str, " (RIGHT)\r\n");
		
		// Вывод строки в UART
		PT_WAIT_UNTIL(Context, UART0_SendStr(str));
	}		

	PT_END(Context); // Завершение протопотока
}
//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////
// Задача Task_Y.
// Измеряет положения джойстика по оси Y с помощью АЦП. В случае изменения
// положения выводит результат в UART.
//////////////////////////////////////////////////////////////////////////
PT_THREAD(Task_Y(struct pt *Context))
{
	static struct pt ContextChild; // Контекст для дочернего протопотока
	static uint8_t adc;
	static uint8_t adc_old = 0;
	static char str[30];

	PT_BEGIN(Context); // Начало протопотока

	// Измерение положения джойстика по оси Y с помощью АЦП.
	// (Вызов дочернего протопотока)
	PT_SPAWN(Context, &ContextChild,
		ReadADC(&ContextChild, ADMUX_MUX_6, &adc));
	
	// Если результат измерения отличается от предыдущего более чем на
	// одну дискрету, то вывод результата в UART
	if (abs(adc_old - adc) > 1)
	{
		adc_old = adc; // Сохраняем результат измерения
		
		// Формирование текстовой строки для вывода в UART
		sprintf(str, "Task_Y: VRy = %d", adc);
		if (adc < 128) strcat (str, " (UP)\r\n");
		else strcat (str, " (DOWN)\r\n");
		
		// Вывод строки в UART
		PT_WAIT_UNTIL(Context, UART0_SendStr(str));
	}

	PT_END(Context); // Завершение протопотока
}
//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////
// Задача Task_SW.
// Переводится в активное состояние с помощью функции MT_TaskSetActive в
// обработчике прерывания по нажатию/отпусканию кнопки SW джойстика.
// Выводит в UART состояние кнопки.
//////////////////////////////////////////////////////////////////////////
PT_THREAD(Task_SW(struct pt *Context))
{
	uint8_t sw;
	static char str[30];

	PT_BEGIN(Context); // Начало протопотока

	// Приостановка задачи на время, необходимое для успокоения дребезга
	// контакта кнопки. После вызова MT_SleepMs задача переходит в ждущее
	// состояние, в котором она не потребляет ресурсы процессора. По
	// прошествии интервала времени, который был указан вторым параметром,
	// задача будет переведена в активное состояние и продолжит свое
	// выполнение после функции MT_SleepMs.
	MT_SleepMs(Context, DEBOUNCE_MS);
	
	if (ACTIVE(SW)) // Если сигнал SW активен
		sw = 0;
	else // Если сигнал SW не активен
		sw = 1;

	// Сброс флага прерывания
	PCIFR |= 1 << PCIF1;
	
	// Разрешение прерывания по изменению уровня на входе PC5
	PCMSK1 |= 1 << PCINT13;
								
	// Формирование текстовой строки для вывода в UART
	sprintf(str, "Task_SW: SW = %d", sw);
	if (sw == 0) strcat(str, " (PRESSED)\r\n");
	else strcat(str, " (RELEASED)\r\n");
	
	// Вывод строки в UART
	PT_WAIT_UNTIL(Context, UART0_SendStr(str));

	// Перевод текущей задачи в пассивное состояние.
	// После этого задача больше не будет вызываться планировщиком,
	// пока не произойдет новое прерывание по нажатию/отпусканию
	// кнопки SW на джойстике.
	MT_TaskSetPassive();

	PT_END(Context); // Завершение протопотока
}
//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////
// Задача Task_SEC.
// Каждую секунду переводится в активное состояние из функции обратного
// вызова CalcSec с помощью MT_TaskSetActive.
// Выводит в UART счетчик секунд, после чего переходит в пассивное
// состояние.
//////////////////////////////////////////////////////////////////////////
PT_THREAD(Task_SEC(struct pt *Context))
{
	uint16_t sec;
	static char str[20];

	PT_BEGIN(Context); // Начало протопотока

	ENTER_CRITICAL(); // Запрет прерываний с сохранением текущего
					// состояния бита глобального разрешения прерываний
					
	sec = CountSec; // Копирование счетчика секунд в локальную переменную
	
	EXIT_CRITICAL(); // Восстановление бита глобального разрешения
					// прерываний

	// Формирование текстовой строки для вывода в UART
	sprintf(str, "Task_SEC: %d sec\r", sec);
	
	// Вывод строки в UART
	PT_WAIT_UNTIL(Context, UART0_SendStr(str));
	
	// Перевод текущей задачи в пассивное состояние.
	// После этого задача больше не будет вызываться планировщиком,
	// пока не произойдет вызов MT_TaskSetActive из функции
	// CalcSec, которая в свою очередь вызывается из
	// обработчика прерывания системного таймера.
	MT_TaskSetPassive();

	PT_END(Context); // Завершение протопотока
}
//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////
// Задача Task_ECHO.
// Считывает байт, принятый из UART, преобразует его в текстовую форму и
// отправляет обратно в UART.
//////////////////////////////////////////////////////////////////////////
PT_THREAD(Task_ECHO(struct pt *Context))
{
	static char rx;
	static char str[20];

	PT_BEGIN(Context); // Начало протопотока

	// Ожидание приема байта из UART.
	// Если имеется принятый байт, то выполнение задачи продолжится, иначе
	// произойдет выход из протопотока и передача управления в планировщик.
	PT_WAIT_UNTIL(Context, UART0_ReadRx(&rx));
	
	// Формирование текстовой строки для вывода в UART
	sprintf(str, "Task_ECHO: Code=%02x\r\n", rx);

	// Вывод строки в UART.
	PT_WAIT_UNTIL(Context, UART0_SendStr(str));

	PT_END(Context); // Завершение протопотока
}
//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////
// Задача Task_BLINK.
// В бесконечном цикле моргает светодиодом.
// С интервалом 5 сек изменяет частоту моргания.
//////////////////////////////////////////////////////////////////////////
PT_THREAD(Task_BLINK(struct pt *Context))
{
	// Режим моргания светодиода HL:
	// 1 - быстрый, 0 - замедленный
	static uint8_t fHighFreqBlinkHL = 0;

	PT_BEGIN(Context); // Начало протопотока
	
	while (TRUE)
	{
		if (MT_TimeoutGet(TIMEOUT_HL) == 0) // Если таймаут истек
		{
			// Если таймаут истек, то меняем режим моргания светодиода и
			// снова устанавливаем таймаут.
			
			// Меняем режим моргания
			fHighFreqBlinkHL = !fHighFreqBlinkHL;
			
			// Устанавливаем таймаут
			//MT_TimeoutSet(TIMEOUT_HL, MS_TO_SYSTICK(TimeBetweenModeHL));
			MT_TimeoutMs(TIMEOUT_HL, TimeBetweenModeHL);
		}

		// Инверсия состояния вывода порта, к которому подключен
		// светодиод.
		CPL(HL);
					

		// Далее, в зависимости от режима моргания, время между
		// переключениями светодиода будет разное.
		
		if (fHighFreqBlinkHL) // Если быстрый режим моргания
		{
			// Заснуть на короткий промежуток времени
			MT_SleepMs(Context, ShortPauseHL);
		}
		else // Если замедленный режим моргания
		{
			// Заснуть на длинный промежуток времени
			MT_SleepMs(Context, LongPauseHL);
		}
	}

	PT_END(Context); // Завершение протопотока
}
//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////
int main(void)
{
	// Настройка тактовой частоты процессора
	//=======================================================================

	#if (DIVIDER_OSC == 1)
	clock_prescale_set(clock_div_1); // Устанавливаем делитель 1/1
	#elif (DIVIDER_OSC == 2)
	clock_prescale_set(clock_div_2); // Устанавливаем делитель 1/2
	#elif (DIVIDER_OSC == 4)
	clock_prescale_set(clock_div_4); // Устанавливаем делитель 1/4
	#elif (DIVIDER_OSC == 8)
	clock_prescale_set(clock_div_8); // Устанавливаем делитель 1/8
	#elif (DIVIDER_OSC == 16)
	clock_prescale_set(clock_div_16); // Устанавливаем делитель 1/16
	#elif (DIVIDER_OSC == 32)
	clock_prescale_set(clock_div_32); // Устанавливаем делитель 1/32
	#elif (DIVIDER_OSC == 64)
	clock_prescale_set(clock_div_64); // Устанавливаем делитель 1/64
	#elif (DIVIDER_OSC == 128)
	clock_prescale_set(clock_div_128); // Устанавливаем делитель 1/128
	#elif (DIVIDER_OSC == 256)
	clock_prescale_set(clock_div_256); // Устанавливаем делитель 1/256
	#else
	#error Unknown divider for MAIN_OSC
	#endif



	
	#if !defined(__AVR_ATmega8__)
	// Работаем с регистром PRR
	power_twi_disable(); // Запретить TWI
	power_timer0_enable(); // Разрешить Таймер 0
	power_timer1_enable(); // Разрешить Таймер 1
	power_timer2_enable(); // Разрешить Таймер 2
	power_spi_disable(); // Запретить SPI
	power_usart0_enable(); // Разрешить USART0
	power_adc_enable(); // Разрешить ADC
	/////////////////////////////////////////////
	#endif


	sei(); // Разрешение прерываний




	// Инициализация портов микроконтроллера
	//====================================================================

	// Инициализация порта, подключенного к светодиоду
	DRIVER(HL, OUT);	// HL - выход
	OFF(HL);			// HL - в пассивное состояние (выключен)

	// Инициализация порта, к которому подключена кнопка
	DRIVER(SW, IN);		// Вход
	DRIVER(SW, PULLUP);	// Подтяжка к питанию





	// Инициализация UART0
	//====================================================================
	UART0_Init();




	// Инициализация АЦП
	//====================================================================
	// Регистр ADMUX.
	// ADMUX_REF_AVCC - Опорное = AVCC (Напряжение питания)
	// ADMUX_DATA_LEFT - Выравнивание результата влево
	//	                (оптимально для получения 8-битного результата)
	ADMUX = ADMUX_REF_AVCC | ADMUX_DATA_LEFT | ADMUX_MUX_0;

	// Регистр ADCSRB.
	// Analog Comparator Multiplexer Disable (Bit 6 = 0)
	// Free Running mode (Bits 2..0 = 000)
	ADCSRB = 0;

	// Регистр ADCSRA.
	// ADCSRA_ADEN - Разрешение АЦП,
	// ADCSRA_ADIF - Сброс флага прерывания,
	// ADCSRA_DIV - Константа, определяющая частоту преобразования АЦП,
	// представляющую собой делитель для F_CPU.
	// ПРИМЕЧАНИЕ: Делитель ADCSRA_DIV вычисляется на основании константы
	// ADC_FREQ_MAX или ADC_FREQ_MIN в файле ADC_Cfg.h
	ADCSRA = ADCSRA_ADEN | ADCSRA_ADIF | ADCSRA_DIV;




	// Инициализация прерывания по нажатию/отпусканию кнопки (порт PC5)
	//====================================================================
	PCIFR |= 1 << PCIF1; // Сброс флага прерывания для группы
						// PCINT8...PCINT14
	PCMSK1 |= 1 << PCINT13; // Разрешение прерывания PCINT13 (порт PC5)
	PCICR |= 1 << PCIE1; // Разрешение группы прерываний PCINT8...PCINT14




	// Инициализация менеджера задач
	//====================================================================
	MT_Init();




	// Инициализация задач
	//====================================================================

	MT_TaskInit(Task_X, TASK_ACTIVE); // Инициализация задачи Task_X

	MT_TaskInit(Task_Y, TASK_ACTIVE); // Инициализация задачи Task_Y
	
	idTask_SW = MT_TaskInit(Task_SW, TASK_PASSIVE); // Инициализация
										// задачи Task_SW и сохранение ID
										// задачи в переменной idTask_SW

	MT_TaskSetPriority(idTask_SW); // Присваеваем задаче, ID которой
									// находится в переменной idTask_SW
									// статус приоритетной
	
	idTask_SEC = MT_TaskInit(Task_SEC, TASK_PASSIVE); // Инициализация
										// задачи Task_SEC и сохранение ID
										// задачи в переменной idTask_SEC
	
	MT_TaskInit(Task_ECHO, TASK_ACTIVE); // Инициализация задачи Task_ECHO
	
	MT_TaskInit(Task_BLINK, TASK_ACTIVE); 
										// Инициализация задачи Task_BLINK




	// Бесконечный цикл (планировщик)
	//====================================================================
	while(1)
	{
		MT_DISPATCH(); // Один проход планировщика
	}
}
//////////////////////////////////////////////////////////////////////////
